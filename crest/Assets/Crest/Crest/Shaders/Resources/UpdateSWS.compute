// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

#pragma kernel Init
#pragma kernel InitGroundHeight
#pragma kernel Advect
#pragma kernel UpdateH
#pragma kernel UpdateVels
#pragma kernel BlurH

#include "HLSLSupport.cginc"

#include "../OceanGlobals.hlsl"
#include "../OceanInputsDriven.hlsl"
#include "../OceanHelpers.hlsl"

SamplerState linear_clamp_sampler;

Texture2D<float> _H0;
RWTexture2D<float> _H1;
Texture2D<float> _Vx0;
RWTexture2D<float> _Vx1;
Texture2D<float> _Vy0;
RWTexture2D<float> _Vy1;
Texture2D<float> _GroundHeightSS;
RWTexture2D<float> _GroundHeightSSRW;
Texture2D<float> _SimulationMask;
RWTexture2D<float> _SimulationMaskRW;

float _Time;
float _DeltaTime;
float _DomainWidth;
float3 _SimOrigin;
float _Res;
float _DrainWaterAtBoundaries;
float _Friction;
float _MaximumVelocity;
float _AddAdditionalWater;
float _TexelSize;

float _ShallowMinDepth;
float _ShallowMaxDepth;
float _BlendPushUpStrength;

float2 IdToWorldXZ_H(uint2 id)
{
	// H grid is centered
	return ((id + 0.5) / _Res - 0.5) * _DomainWidth + _SimOrigin.xz;
}
float2 IdToWorldXZ_GroundHeight(uint2 id)
{
	// H and GroundHeight are aligned
	return IdToWorldXZ_H(id);
}
float2 IdToWorldXZ_Vx(uint2 id)
{
	// Vx grid is offset right half a texel
	return ((id + float2(1.0, 0.5)) / _Res - 0.5) * _DomainWidth + _SimOrigin.xz;
}
float2 IdToWorldXZ_Vy(uint2 id)
{
	// Vy grid is offset forward half a texel
	return ((id + float2(0.5, 1.0)) / _Res - 0.5) * _DomainWidth + _SimOrigin.xz;
}

float2 WorldXZToUv_H(float2 worldXZ)
{
	// H grid is centered
	return (worldXZ - _SimOrigin.xz) / _DomainWidth + 0.5;
}
float2 WorldXZToUv_GroundHeight(float2 worldXZ)
{
	// Aligned to H
	return WorldXZToUv_H(worldXZ);
}
float2 WorldXZToUv_Vx(float2 worldXZ)
{
	// Vx grid is offset right half a texel
	return (worldXZ - _SimOrigin.xz) / _DomainWidth + 0.5 - float2(0.5 / _Res, 0.0);
}
float2 WorldXZToUv_Vy(float2 worldXZ)
{
	// Vy grid is offset forward half a texel
	return (worldXZ - _SimOrigin.xz) / _DomainWidth + 0.5 - float2(0.0, 0.5 / _Res);
}

float SampleH(float2 worldXZ)
{
	return _H0.SampleLevel(linear_clamp_sampler, WorldXZToUv_H(worldXZ), 0.0).x;
}
float SampleGroundHeight(float2 worldXZ)
{
	return _GroundHeightSS.SampleLevel(linear_clamp_sampler, WorldXZToUv_GroundHeight(worldXZ), 0.0).x;
}
float SampleVx0(float2 worldXZ)
{
	return _Vx0.SampleLevel(linear_clamp_sampler, WorldXZToUv_Vx(worldXZ), 0.0).x;
}
float SampleVy0(float2 worldXZ)
{
	return _Vy0.SampleLevel(linear_clamp_sampler, WorldXZToUv_Vy(worldXZ), 0.0).x;
}

[numthreads(8, 8, 1)]
void InitGroundHeight(uint2 id : SV_DispatchThreadID)
{
	const float2 worldXZ = IdToWorldXZ_GroundHeight(id);

	uint slice0, slice1;
	float lodAlpha;
	PosToSliceIndices(worldXZ, 0.0, _CrestCascadeData[0]._scale, slice0, slice1, lodAlpha);

	const float3 uv0 = WorldToUV(worldXZ, _CrestCascadeData[slice0], slice0);
	const float3 uv1 = WorldToUV(worldXZ, _CrestCascadeData[slice1], slice1);

	const float wt_0 = (1.0 - lodAlpha) * _CrestCascadeData[slice0]._weight;
	const float wt_1 = (1.0 - wt_0) * _CrestCascadeData[slice1]._weight;

	float2 groundHeight_seaLevelOffset =
		wt_0 * _LD_TexArray_SeaFloorDepth.SampleLevel(LODData_linear_clamp_sampler, uv0, 0).x +
		wt_1 * _LD_TexArray_SeaFloorDepth.SampleLevel(LODData_linear_clamp_sampler, uv1, 0).x;
	float g = groundHeight_seaLevelOffset.x;

	// Mask is directly based off depth at the moment
	// TODO Needs sea level offset, not just sea level. Like groundHeight_seaLevelOffset above.
	float depth = _OceanCenterPosWorld.y /* + groundHeight_seaLevelOffset.y*/ - g;
	_SimulationMaskRW[id] = 1.0 - saturate((depth - _ShallowMinDepth) / _ShallowMaxDepth);

	g = max(0.0, g - _SimOrigin.y);

	_GroundHeightSSRW[id] = g;
}

[numthreads(8, 8, 1)]
void Init(uint2 id : SV_DispatchThreadID)
{
	const float2 worldXZ = IdToWorldXZ_H(id);

	float h = _OceanCenterPosWorld.y - _SimOrigin.y;
	h = max(0.0, h - SampleGroundHeight(worldXZ));

	h += _AddAdditionalWater;

	_H1[id.xy] = h;
	_Vx1[id.xy] = 0.0;
	_Vy1[id.xy] = 0.0;
}

[numthreads(8, 8, 1)]
void Advect(uint2 id : SV_DispatchThreadID)
{
	// H
	{
		const float2 worldXZ_H = IdToWorldXZ_H(id);

		const float vx = SampleVx0(worldXZ_H);
		const float vy = SampleVy0(worldXZ_H);

		const float2 worldXZAdvected = worldXZ_H - _DeltaTime * float2(vx, vy);

		_H1[id] = SampleH(worldXZAdvected);
	}

	// Vx
	{
		const float2 worldXZ_Vx = IdToWorldXZ_Vx(id);
		
		const float vx = SampleVx0(worldXZ_Vx); // Can be load
		const float vy = SampleVy0(worldXZ_Vx);

		const float2 worldXZAdvected = worldXZ_Vx - _DeltaTime * float2(vx, vy);
		float vxAdvected = SampleVx0(worldXZAdvected);

		const float h_vx = SampleH(worldXZAdvected);
		const float friction = _Friction * _DeltaTime / max(0.001f, pow(h_vx, 1.333333f));
		vxAdvected -= abs(vxAdvected) * vxAdvected * friction;

		vxAdvected = clamp(vxAdvected, -_MaximumVelocity, _MaximumVelocity);

		_Vx1[id] = vxAdvected;
	}

	// Vy
	{
		const float2 worldXZ_Vy = IdToWorldXZ_Vy(id);
		
		const float vx = SampleVx0(worldXZ_Vy);
		const float vy = SampleVy0(worldXZ_Vy); // Can be load
		
		const float2 worldXZAdvected = worldXZ_Vy - _DeltaTime * float2(vx, vy);
		float vyAdvected = SampleVy0(worldXZAdvected);

		const float h_vy = SampleH(worldXZAdvected);
		const float friction = _Friction * _DeltaTime / max(0.001f, pow(h_vy, 1.333333f));
		vyAdvected -= abs(vyAdvected) * vyAdvected * friction;

		vyAdvected = clamp(vyAdvected, -_MaximumVelocity, _MaximumVelocity);

		_Vy1[id] = vyAdvected;
	}
}

[numthreads(8,8,1)]
void UpdateH(uint2 id : SV_DispatchThreadID)
{
	float h = _H1[id];

	const uint x = id.x;
	const uint y = id.y;

	const float2 worldXZ = IdToWorldXZ_H(id);

	float pump = 0.0;

	if (h > 0.01)
	{
		float2 offset = abs(id / float(_Res) - 0.5);
		float maxOff = max(offset.x, offset.y);

		// Drain water out at boundary of domain. This seems to work ok. 
		pump += _DrainWaterAtBoundaries * smoothstep(0.4, 0.5, maxOff);

		uint slice0, slice1;
		float lodAlpha;
		PosToSliceIndices(worldXZ, 0.0, _CrestCascadeData[0]._scale, slice0, slice1, lodAlpha);

		const float3 uv0 = WorldToUV(worldXZ, _CrestCascadeData[slice0], slice0);
		const float3 uv1 = WorldToUV(worldXZ, _CrestCascadeData[slice1], slice1);

		const float wt_0 = (1.0 - lodAlpha) * _CrestCascadeData[slice0]._weight;
		const float wt_1 = (1.0 - wt_0) * _CrestCascadeData[slice1]._weight;

		float dispy =
			wt_0 * _LD_TexArray_AnimatedWaves.SampleLevel(LODData_linear_clamp_sampler, uv0, 0).y +
			wt_1 * _LD_TexArray_AnimatedWaves.SampleLevel(LODData_linear_clamp_sampler, uv1, 0).y;

		// TODO Needs sea level offset, not just sea level. Like groundHeight_seaLevelOffset above.
		float wavey = dispy + _OceanCenterPosWorld.y;
		float simH = h + _SimOrigin.y + _GroundHeightSS[id];
		if(wavey > simH)
		{
			pump += _BlendPushUpStrength * _SimulationMask[id] * (wavey - simH);
		}
	}


	float outPump = 30.0;// 30.0;
	float vxp = (x == uint(_Res - 1)) ? outPump : _Vx1[id];
	float vyp = (y == uint(_Res - 1)) ? outPump : _Vy1[id];
	float vxm = (x == 0) ? -outPump : _Vx1[uint2(x - 1, y)];
	float vym = (y == 0) ? -outPump : _Vy1[uint2(x, y - 1)];
	const float dx = (vxp - vxm) / _TexelSize;
	const float dy = (vyp - vym) / _TexelSize;
	const float divergence = dx + dy;

	// Update height based on total flow in minus total flow out
	const float hvel = -h * divergence;
	//hvel = clamp(hvel, -32.0f, 32.0f);

	h += _DeltaTime * hvel + pump;
	h = max(h, 0.0);

	// Dry - force to 0
	//if (h < 0.001) h = 0.0;

	_H1[id] = h;
}

[numthreads(8, 8, 1)]
void UpdateVels(uint2 id : SV_DispatchThreadID)
{
	// Height before vel
	const float2 worldXZ_H0 = IdToWorldXZ_H(id);
	const float g0 = _GroundHeightSS[id];
	const float h0 = _H1[id];

	const uint x = id.x;
	const uint y = id.y;
	const uint xp = min(x + 1, _Res - 1);
	const uint yp = min(y + 1, _Res - 1);

	const float gravity = 9.81f;

	// Vx
	{
		float vx = _Vx1[id];

		const float2 worldXZ_H1 = IdToWorldXZ_H(uint2(xp, y));
		const float g1 = _GroundHeightSS[uint2(xp, y)];
		const float h1 = _H1[uint2(xp, y)];

		const float hdiff = (h1 + g1) - (h0 + g0);
		//if (fabs(hdiff) > maxDiff) hdiff = sign(hdiff) * maxDiff;

		float accel = -gravity * hdiff / _TexelSize;

		vx += _DeltaTime * accel;

		if (accel < 0 && h1 < 0.001)
		{
			vx = 0.0;
		}
		else if (accel > 0 && h0 < 0.001)
		{
			vx = 0.0;
		}

		/*if (abs(vx) > maxVel)
		{
			vx = sign(vx) * maxVel;
		}*/

		_Vx1[id] = vx;
	}

	// Vy
	{
		float vy = _Vy1[id];

		const float2 worldXZ_H1 = IdToWorldXZ_H(uint2(x, yp));
		const float g1 = _GroundHeightSS[uint2(x, yp)];
		const float h1 = _H1[uint2(x, yp)];

		const float hdiff = (h1 + g1) - (h0 + g0);
		//if (fabs(hdiff) > maxDiff) hdiff = sign(hdiff) * maxDiff;

		float accel = -gravity * hdiff / _TexelSize;

		vy += _DeltaTime * accel;

		if (accel < 0 && h1 < 0.001)
		{
			vy = 0.0;
		}
		else if (accel > 0 && h0 < 0.001)
		{
			vy = 0.0;
		}

		/*if (abs(vx) > maxVel)
		{
			vx = sign(vx) * maxVel;
		}*/

		_Vy1[id] = vy;
	}
}

[numthreads(8, 8, 1)]
void BlurH(int2 id : SV_DispatchThreadID)
{
	float result = 0.0;
	float twt = 0.0;
	const int rad = 2;

	float hcenter = _H0[id];
	if (hcenter < 0.001)
	{
		_H1[id] = 0.0;
		return;
	}

	for (int y = -rad; y <= rad; y++)
	{
		for (int x = -rad; x <= rad; x++)
		{
			int2 idx;
			idx.x = clamp(id.x + x, 0, _Res - 1);
			idx.y = clamp(id.y + y, 0, _Res - 1);

			float h = _H0[idx];
			float wt = h >= 0.001 ? 1.0 : 0.0;
			result += wt * h;
			twt += wt;
		}
	}

	_H1[id] = twt > 0.0 ? result / twt : hcenter;
}
